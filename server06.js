// однопоточное node.js приложение должно быть асинхронным

// у этого Back-end один поток каторый умеет выполнять какие то операции с процессором
// Back-end и поток один но много различных браузеров могут делать запросы на этот Back-end
// и этот Back-end должен максимально быстро обработать запрос и отдать response
// если перед репронсом написать код каторый заставит процессор ждать несколько секунд это время отразится на всех реквестах катрые прилетели
// на этот Back-end потому что поток всего один
// в один момент времени Back-end может выполнять только одну колбек функцию
// если допустим дбавить синхронно в колбек функцию 3 секундную задержку и делать запрос из 4 вкладок в браузере последний запрос будет 
// обрабатываться через 12 секунд все реквесты выстраиваются в очередь

// что бы такова не было надо испльзовать асинхронность тоесть один паток отдает выплнение 3 секундной операции node.js и эта опрация 
// будет выполняться на уровне операционной системы поток представитель движка V8 и он передает их в node.js
// в это время поток будет принимать другие реквесты когда операции будут выполнены будет вызван колбек
// если запросы пришли практически одновременно то через 3 секунды они и вернутся практически одновременно одна за одной
// что бы сделать такое ожиданеи асинхронным можно использовать функцию setTimeout() и в ней уже выполнять все опреации
// когда вызывается setTimeout() в ней задержка 3 секунды и колбек функцию обратного вызова тоесть отдаем ее в node.js
// все вкладки делают запрос практически одновременно и отдает ответ через 3 секунды практически одновременно

// если вынести response.end() за пределы setTimeout() switch case то старница обновляется ответ приходит но в нем ничего нет пустой
// эо происходит потому что асинхронная опреация одается node.js но праграма продолжает выполняться дальше через 3 секунды setTimeout()
// выполнился но респонс уже завершен response.end() и в него не успел записаться response.write(data)


// работа с файлами 
// когда прилетит запрос на /home прочитать содержимое файла home.html и вернуть его как response
// для того что бы node.js могла обращаться к файлам надо подключить модуль fs (File system)

// считывание файлов это очень медленная операция поток не должен ждать пока к нему синхронно вернется файл
// readFileSync будет синхронно прочитывать файл
// readFile  будет асинхронно прочитывать файл и когда readFile прочитает этот файл вызовится колбек в каторый передается 2 аргументом
// (err, data) err если произшла ошибка, в data запишется файл если все хорошо
// когда надо прочитать 1 файл тоесть одну задержку проблем нет
// но когда в реквесте в логике много запросов на файлы и на базу данных и т.д. получается (callback hell) Ад обратных вызовов
// асинхронная лгика пишется на промисах (Промисификация)
// некаторые асинхронные интерфейсы каких то бибилиотек каторые подключаются в проект не используют промиисы и приходится вокруг них 
// делать обертку

const http = require('http')
const fs = require('fs') // в переменную fs возврощается объект (File system)

const server = http.createServer(async (request, response) => {
    switch (request.url) {
        case '/home': {
            // const start = new Date(); // записываем в start текущую дату время
            // while(new Date() - start < 3000) { // пока время сгенерированое в этой строке не будет больше start на 3 секунды код не пойдет
            //     // дальше
            //     console.log(new Date() - start)
            // }

            // setTimeout(() => {
            //     const data = 'best free online course'
            //     response.write(data)
            //     // response.end()
            // }, 3000)
            // const data = 'best free online course'
            // response.write(data)
            // response.end()

            // const data = fs.readFileSync('pages/about.html') // readFileSync метод объекта fs прочитай файл синхронно и записывает его в data
            // fs.readFile('pages/about.html', (err, data) => {
            //     if (err) response.write('some error')
            //     else response.write(data)
            //     response.end()
            // })
            // response.write(data)
            try { // try catch испльзуетсяя на случай ошибки что бы не слег весь бекенд 
                // try то что пытаемся выполнить если не выполнилось то выполняется catch
                const data = await readFile('pages/about.html') // если await убрать то в data будут лежать не данные а промис потому что 
                // readFile возвращает Promise но await говорит что надо жать пока промис зарезолвится
                // програма с помощью await обрывается поток освобождается и может принимать следующие запросы
                response.write(data)
                response.end()
            } catch(err) {
                response.write('something wrong, 500')
                response.end()
            }
            
            break;
        }
        case '/about': {
            
            // setTimeout(() => {
            //     response.write('ABOUT COURSE')
            //     response.end()
            // }, 3000)
            await delay(3000)
            // промис облегчает задачу тем что исчезает колбек setTimeout но выполнение эих 3 секунд всеравно отдается 
            // node.js и поток может принимать запросы дальше
            // теперь вызов delay(3000) будет ждать но не синхронно а так же с колбеком асинхронно но сам колбек не пишется синтаксически
            // после отработки delay(3000) 3 секунд код выполняется дальше
            // на сранице выдает ABOUT COURSE тоесь успеват записать ответ response.write('ABOUT COURSE') а после закрыть response.end()
            response.write('ABOUT COURSE')
            response.end()
            break;
        }
        default: {
            response.write('404 not found')
            response.end()
        }
    }
    // response.end()
})

server.listen(3003)

// что бы сделать промисификацию напишим функцию delay каторая будет ждать ms секунд
const delay = (ms) => {
    return new Promise((resolve, reject) => { // delay будет возвращать новый промис
        setTimeout(() => {                    // он будет ждать ms секунды 
            resolve()                         // после эого промис зарезолвим
        }, ms)
    })
}

const readFile = (path) => { // readFile будет принимать путь к файлу
    return new Promise((resolve, reject) => {  // readFile будет оборачивать логику считывания файла в промис (Промисификация)
        fs.readFile(path, (err, data) => {     // колбек остался но мы его спрятали за промисом
            if (err) reject(err) // если ошибка при прочитке файла промис выдает reject с ошибкой err
            else resolve(data)   // если все хорошо резолвим с той датой каторой прочитали из файлика
        })
    })
}

