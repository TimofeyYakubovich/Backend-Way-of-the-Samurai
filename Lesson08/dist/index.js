"use strict";
// Express + nodemon + TypeScript.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// сервер, написанный на “чистом” Node.js. В катором большое количество “роутов” и “кейсов”:
// В реальном приложении может быть огромное количество таких адресов. При этом, на каждый адрес идут POST, PUT, DELETE - запросы, которые мы должны как-то обрабатывать и понимать, что с ними делать. Соответственно, эту логику маршрутизации нужно как-то описать и проработать стандартные механизмы с телом запроса (body), “query”, “URI” параметрами.
// Нужно возвращать ответы (response). И при этом не делать вручную много рутинной работы. И в этом контексте нам нужна помощь. И помощь эта состоит в использовании готовой библиотеки. 
// Не будем писать свою библиотеку, а используем готовую - Express. Эта библиотека решает ряд вопросов. С её помощью мы можем построить определённую архитектуру, “наплодив” много промежуточных слоёв, реализовав какие-то свои “кастомные” решения. Тем не менее, Express не является полноценным фреймворком, это библиотека - сторонняя разработка других программистов, пакет, который нам нужно в наш проект подключить.
// Сейчас у нас нет проекта, у нас есть папка с файлом:
// Здесь мы пишем дефолтный код, чтобы проимпортировать файловую систему, либо http-модуль, который по умолчанию идет с Node.js:
// Но мы хотим устанавливать пакеты, и для этого нам нужен npm (Node.js package manager). Устанавливается он автоматически, когда вы устанавливаете Node.js.
// Но мы не будем использовать npm, а будем использовать yarn - оптимизированный npm. С yarn гораздо меньше проблем. Он многое оптимизирует под “капотом” и мы не думаем о том, о чём мы думать не должны: о настройках, тюнинге и т.д.
// что бы установить yarn глобально npm install --global yarn
// Если написать в терминале команду “yarn”: То yarn автоматически проанализирует, какие зависимости ему нужно установить, и установит их
// Но зависимостей нет. Поэтому папка “node_modules”, по сути говоря пустая, не считая каких-то вспомогательных мета-файлов.
// Почему мы не должны были писать yarn? Потому что наша папка как проект еще нигде не определена.
// Чтобы папка стала проектом, в ней должен находиться самый главный файл - package.json. С точки зрения Node.js этот файл будет являться проектом.
// Для того, чтобы он появился, нужно написать: yarn init --yes
// Напишем команду yarn. Он проанализирует файл ”package.json” и попытается установить зависимости.
// А какие зависимости нужны? Нам нужен Express. Мы хотим, чтобы наш проект зависел от библиотеки Express.
// Мы установим пакет. Для этого пишем команду: yarn add express
// в ”package.json” появился ключ “dependencies”, в котором появилась зависимость “express”
// Теперь вместо создания сервера с помощью этой логики:  const http = require('http') const fs = require('fs') http и fs поумолчанию есть в node.js
// Мы создадим сервер с помощью библиотеки express, которая по сути внутри себя содержит что-то похожее, только более навороченное.
// const express = require('express') //require говорит, что мы зависим от express’a. Раньше мы зависели от (‘fs’), (‘http’) модулей.
const express_1 = __importDefault(require("express")); // Заменяем импорт через require
const app = (0, express_1.default)(); // Далее мы создаём некое приложение app с помощью вызова функции express
const port = 3000;
app.get('/', (req, res) => {
    const a = 4; // как только придёт запрос на такой (“/”) эндпоинт, запустится этот коллбэк”.
    if (a > 5) {
        res.send('Ok!');
    }
    else {
        res.send('Hello World!!! “watcher”!!!!!!!');
    }
});
app.get('/samurais', (req, res) => {
    res.send('Hello samurais!!!!!!!!!!!');
});
app.post('/samurais', (req, res) => {
    res.send('We have created samurai');
});
app.listen(port, () => {
    console.log(`Example app listening on port ${port}`);
});
// Запускаем наше приложение: node index.js в адресной строке вводим localhost:3000
// с консоли браузера отправляем post-запрос на этот же эндпоинт с помощью нативной команды fetch('http://localhost:3000/samurais', { method: 'post'})
// в Network видим, что отправили post-запрос: В response видим: We have created samurai
// Таким образом наш бэкенд реагирует на запросы, их типы и URL’ы, которые мы ему отправляем. 
// Следующим шагом будет настройка автоматического перезапуска системы, когда мы меняем какой-либо файл.
//Программа, которая следит за файлами, за системой или вообще чем-либо, называется watcher. Она следит за файлами и перезагружает систему. И такая программа, которую мы будем использовать, называется “nodemon”
// На сайте npm этот пакет предлагается установить глобально. Но глобально устанавливать не рекомендуется. Почему? Потому что чем меньше у нас установлено глобальных инструментов и чем больше их установлено в самой папке проекта локально, тем лучше. 
// Выбираем этот вариант, который установит пакет в devDependencies это библиотеки и инструменты, которые нужны нам в момент разработки.
// Воспользуемся командой для yarn: yarn add nodemon -D
// Если вы начали пользоваться yarn - ни в коем случае не устанавливаете больше ничего с помощью npm, или наоборот.
// Теперь запускаем приложение, но с помощью nodemon команды “yarn nodemon index.js”. Видим, что наша программа запустилась:
// Следующим шагом нам нужно научиться проводить отладку (“дебажить”)
// приложение. Отладка - выполнение программы по шагам, изучение контекста, памяти, переменных, состояния, чтобы выяснить, в каком шаге мы ошиблись, почему наше приложение ведёт себя не так, как нужно.
// Для того, чтобы запустить программу с отладкой, нужно написать следующую команду: “yarn nodemon --inspect index.js”.
// Видим, что появились web-socket соединения, к которым может подключиться наш браузер.
// Заходим в Sources и находим файл “index.js” и ставим точку останова на 36-й строке:
// Делаем get-запрос и видим, что сервер “завис”, потому что программа находится в режиме отладки:
// Для перехода по строкам используем клавишу “F10”, и, наводя курсор на различные участки кода, можем видеть некоторую полезную информацию:
// Дальнейшее нажатие на “F10” перекинет нас на внутреннюю “кухню” библиотеки express, поэтому можно нажать “F8”, тем самым сказав отладчику “отпустить” программу до следующей точки останова, если такая есть.
// Важный момент. В режиме отладки мы можем изменять значения каких-либо переменных, чтобы смоделировать то или иное поведение, и понять, как работает наша программа.
// TypeScript - надмножество над JavaScript. Браузер, Node.js, движок V8 не понимает TypeScript. Он сначала компилируется в JavaScript и затем “скармливается” движку.
// TypeScript нужен ради строгой типизации, потому что строгая типизация позволяет совершать меньше ошибок в момент написания кода.
// Устанавливаем TypeScript (add typescript) и ts-node (ts-node) - утилиту, которая нужна для полноценной работы nodemon и в целом node.js. Нам нужен TypeScript для express (@types/express), так как в этой библиотеке по умолчанию не “зашиты” типы. Также нам нужны типы для Node.js (@types/node). И всё это установим в devDependencies (-D):
// yarn add typescript ts-node @types/express @types/node -D
// Установка завершена, и как будто ничего не поменялось. И всё потому, что у нас нет ни одного файла с расширением “.ts”.
// Теперь изменим расширение файла “index.js” на “index.ts”:
// Запускаем проект точно так же, только пишем “index.ts”: yarn nodemon --inspect index.ts
// После запуска будет много ошибок ввиду того, что TypeScript файл с флагом “--inspect” нужно запускать с определёнными настройками. Запустим программу без этого флага: // yarn nodemon index.ts
// Перейдём на более современный синтаксис работы с модулями. Заменяем импорт через require Запускаем и видим ошибку
// Мы установили TypeScript в проект и у нас должен быть доступен TypeScript-компилятор (tsc). Но, так как мы установили TypeScript локально, а не глобально, то tsc у нас доступен не будет.
// Мы можем проверить версию локально установленного tsc: yarn tsc -v
// Либо наш файл “скормить” компилятору файл “index.ts”, чтобы он превратил его в “index.js”: yarn tsc index.ts
// И у нас дополнительно появился файл “index.js
// Перейдя в файл “index.js”, можем увидеть скомпилированный код. Удалим файл “index.js”.
// Чтобы TypeScript правильно компилировал, нам его нужно правильно сконфигурировать. Для этого мы должны прописать команду: yarn tsc --init
// И в нашей папке появился файл “tsconfig.json” с различными настройками.
// В файле “tsconfig.json” раскомментируем строку с настройкой “outDir” и скажем компилятору “класть” все скомпилированные файлы не рядом с “тайпскриптовыми”, а в папку “dist” ./dist.
// Скомпилируем все “.ts”-файлы: yarn tsc
// И увидим, что скомпилированные файлы теперь лежат в папке “dist”:
// Для структурирования нашей программы файл “index.ts” “положим” в папку “src”.
// Файл “index.js”, который лежит в папке “dist”, мы можем запустить и при этом инспектировать нашу “джаваскриптовую” программу: yarn nodemon ./dist/index.js 
// yarn nodemon --inspect ./dist/index.js 
// Резюмируя, мы будем открывать два терминала и запускать две команды. Первой командой в первом терминале мы будем запускать “yarn tsc” и тем самым компилировать файлы.
// В другом терминале мы будем запускать nodemon, который следит за папкой “dist”. Как только мы изменим наш “.ts”-файл, перекомпилируем программу (в первом терминале), изменится файл “index.js” и автоматически перезапустится приложение.
// Единственный негативный момент это то, что нам приходится вручную перекомпилировать. Но вручную этого можно не делать. Мы можем запустить компилятор с флагом “-w” (в режиме “watcher”): yarn tsc -w
// Наш компилятор запустился и ждет когда наши “.ts”-файлы изменятся
// Мы можем сделать это одной командой, как делали до этого. Но тогда возникла одна проблема: нельзя было запустить “.ts”-файл с флагом “--inspect”. Это можно пофиксить конфигурационным файлом nodemon.
// Но лучше использовать две команды - для того, чтобы чётко представлять и помнить “флоу”, который происходит на самом деле
// 1. Компиляция, на этапе которой может произойти какая-то ошибка. И эту ошибку мы можем “отловить” ещё до запуска программы.
// 2. Запуск программы.
// У нас почти всё готово. За исключением необходимости постоянно прописывать две команды: “yarn tsc -w” и “yarn nodemon .\dist\index.js”.
// Напишем скрипты, которые поместим в “package.json”, и с помощью которых будет проще запускать эти две команды.
// В папке “package.json” добавим свойство “scripts” и необходимые команды
// Запустить эти команды мы можем, нажав на иконку “play” напротив скриптов. После чего откроется другой терминал, где будет запущена наша программа:
// Также можем нажать на файл “package.json”правой кнопкой мыши и выбрать “Show npm Scripts”. Появится вкладка со скриптами, которые мы можем запустить двойным кликом:
// Не все IDE могут иметь такие возможности запуска. Данные скрипты можно запустить и через терминал командами “yarn watch” в одном терминале и “yarn dev” в другом.
