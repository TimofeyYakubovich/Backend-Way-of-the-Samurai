// Rest API, RESTful API (интерфейс взаимодействия клиента и сервера каторые базируются на HTTP протоколе)
// Rest API это определенные правила (спецификация) по каторым устанавливается связь между клиентом и сервером
// как через протокол HTTP найти общий язык между клиентом и сервером
// Rest API, RESTful API это набор рекомендаций и правил каторые дают нам форму для общения между клиентом и сервером

// Front делает HTTP запросы на Back-end на эндпоинты (адреса) их может быть много, клиенту нужны ресурсы (данные), с помощью эндпоинтов
// описываются ресурсы каторые нужны клиенту

// fetch('http://localhost:3003/api/users') делается запрос за ресурсом /users
// http://localhost:3003/api обыно BaseURL базовый адрес сервера
// fetch('http://localhost:3003/api/users/123') делается запрос на юзера с id 123
// fetch('http://localhost:3003/api/users/123/books') делается запрос на все книги юзера с id 123
// fetch('http://localhost:3003/api/users/123/books//55435') делается запрос на конкреттную книгу 55435 юзера с id 123

// через эндпоинт получаем доступ к ресурсу (данные) для того что бы запрос пришел на нужный эндпоинт описывается URL адреса

// crud операции Create — создание Read — чтение Update — обновление Delete — удаление

// методы запроса HTTP протокола

// fetch('http://localhost:3003/api/users/123', {method: 'GET'})     (Read)
// fetch('http://localhost:3003/api/users/123', {method: 'DELETE'})  (Delete)
// fetch('http://localhost:3003/api/users', {method: 'POST'})    (Create)
// как правило не созадется users с конкретным id отправляется запрос на ресурс users
// fetch('http://localhost:3003/api/users/123', {method: 'PUT'})     (Update)
// fetch('http://localhost:3003/api/users/123', {method: 'PATCH'})   (Update)
// можно отправлять разные запросы на один и то же эндпоинт что бы Back-end понмал что надо сделать с этим ресурсом

// GET запрос когда клиент хочет что получить он как правило ничего не передает только URL адрес 
// например если надо получить все книги fetch('http://localhost:3003/books')
// но если над получить конкретную книгу fetch('http://localhost:3003/books/43241')
// после /books/43241 добовляется id и этот id является параметором он может быть разный 
// fetch('http://localhost:3003/books/43241')
// fetch('http://localhost:3003/books/77343') // URL PARAMETER
// с точки зрения бекенда это один и тот же адрес эндпоинт только с разными id

// другая ситуация когда надо что то передать на Back-end и это что является не обязательным
// данные являюстя какими то дополнительными для уточнения например все книги за 2022 год или конкретного автора
// такие уточнения добовляются как Query-параметры через ? соединяются &
// fetch('http://localhost:3003/api/books?author-fowler&year=2022', {method: 'GET’})
// ?author-fowler&year=2022 конкретный автор и год
// fetch('http://localhost:3003/api/books?year=2022&limit=100&sort-title', {method: 'GET'})
// тоесть адрес ресурса остался тот же http://localhost:3003/api/books надо получить все книги 
// но конкретно за 2022 год year=2022 лимит 100 штук limit=100 и отсортировать по заголовкам sort-title
// удаляя эти Query-параметры ресурс остается тем же

// DELETE запрос тоже самое что и GET не нуждается в дополнительной передаче данных
// fetch('http://localhost:3003/api/books/563', {method: 'DELETE'})
// fetch('http://localhost:3003/api/users/123/books//55435', {method: 'DELETE'})
// fetch('http://localhost:3003/api/books?year=2022', {method: 'DELETE'})

// POST запрос
// POST запрос подразумевает создания чего либо (ресурса) как правило не пишется id в самом URL если олько например создать для конкретного
// пользователя новую книгу fetch('http://localhost:3003/api/users/123/books', {method: 'POST'})

// информацию он новой объекте в теории можно было бы закинуть ввиде Query строки
// fetch('http://localhost:3003/api/users/123/books?title=JS&author=dimych', {method: 'POST'})
// но таких значений может быть очень много целый файл и адресная строка не может быть очень длинной
// поэтому обычно испоьзуют дополнительное свойство body: тело запроса payload полезная нагрузка оно может быть очень бльшим

// fetch('http://localhost:3003/api/users/322/books', {method: 'POST', body: json.stringify({ title: 'DS - Samurai Way",
// author: 'Dimych' }) }) // payload


// PUT запрос аналогичный с POST

// например над обновить книгу с id 324 у пользователя с id 322
// она будет заменана на данные в body
// PUT запрос в body над указывать полностью все характеристики даже если обновить надо что то одно
// fetch('http://localhost:3003/api/users/322/books/324', {method: 'POST', body: json.stringify({ title: 'DS - Samurai Way",
// author: 'Dimych' }) }) // payload

// PATCH запрос тоже самое что и PUT
// когда отправляется PUT отправляется набор всех свойств этого ресурса
// при PATCH запросе в body указывается конкрено те свойства каторые надо поменять

// fetch('http://localhost:3003/api/users/322/books/324', {method: 'POST', body: json.stringify({ title: 'DS - Samurai Way" }) }) // payload


// передача дополнитльных данных с запросом каторые не представляют наш домен предметную область книги и пользователи например
// есть еще данные о данных метаданные (заголовки)
// заголовки уходят как с реквестом так и возвращаются с респонсом
// как правило клиент нативный fetch отправляет заголовки подефолту
// при PUT или POST запросе мы отправили json формат объект
// но заголовок Content-Type: text/plain;charset-UTF-8 тип контента text оесть бекенд может не опнять что это json
// поэтому на клиенте при отправке запроса надо указываь заголовки 

// fetch('http://localhost:3003/api/users/322/books/324', {method: 'POST', body: json.stringify({ title: 'DS - Samurai Way",
// author: 'Dimych' }), headers: { "content-type": "application/json" } }) // payload

// еще часто в headers добовляют авторизационные токины которые говорят кто отправляет запрос

// Back-end тоже отправляет при респонсе тело ответа 
// помимо того что отдаются какие то данные payload и заголовки возвращается так же статус код HTTP status code

// Информационные ответы (100 – 199)
// Успешные ответы (200 – 299)
// Сообщения о перенаправлении (300 – 399)
// Ответы клиента на ошибку (400 – 499) клиент отправил что то кривое например 404 нет такова ендпоинта 401 не авторизован
// Ответы сервера на ошибки (500 – 599)
// или например хотм отправить feedback тоже надо отправить body ошибка 400 (Bad Request) не хватает чего то
// в таком ответе тоже может придти тело и в нем уточнение что не так
// множество кодов каторые мы выберем для своего проекта оно обсолютно регламентируется внутри проекта каторые мы определили но есть
// общепринятые договоренности



// бекенд описывает бизнес логику по работе с какими то сущностями (ресурсами) к этим ресурсам предоставляются эндпоинты
// клиенты шлют запросы на эти эндпоинты (адреса) к каждому ажресу цепляется программная логика 
// клиент отправляет метод запроса подсказывая что он хочет сделать с ресурсом 
// он отправляет данные либо в самом URL прописаные Query-параметры через ? или URL PARAMETER id
// если этих данных много он передаются в body