
// Мы должны делать проверку того, что наше приложение, наш бэкенд, работает. Проверка равно тестирование. По своей сути тестирование представляет собой определённые концепции, связанные с написанием тестов, пирамиду тестирования: интеграционные тесты, E2E тестирование, unit-тесты и т.д. 

// Есть определённые правила и принципы, по которым строятся тесты. В данном уроке мы всё это отбросим. И, хоть мы будем писать тесты, мы это не будем называть тестированием. А будем называть это проверкой.

// Мы проверяем, что наш API работает. А уже как какой-то побочный эффект у нас остаются тесты. В какой-то степени не совсем идеальные тесты. Но, тем не менее, сложно поспорить с тем, что наличие этих тестов очень полезно

// Когда “фронтендер” пишет своё приложение, он обязательно запускает его и у него обязательно есть user interface, который он непосредственно видит глазами. Он смотрит на этот интерфейс. Руками он с ним взаимодействует и проверяет, что приложение работает предсказуемо, ожидаемо - так, как он его запрограммировал. За счёт чего это происходит? За счёт того, что у нас есть user interface (UI), который подразумевает наличие пользователя. 

// Мы, как backend-разработчики, сидим «в подвале» и пишем скучную API. Интерфейс вроде есть и там, и там. Но это программный интерфейс, с которым взаимодействует другая программа: frontend-приложение. И нам тестировать нашу API уже не так уж интересно.

// В какой-то степени frontend тестирует API - он с ним взаимодействует и егопроверяет. Нечто подобное мы делали, когда писали код, который делает запросы к нашей API. Мы проверяли, что наша API работает. Именно проверяли. Не тестировали.

// У нас, как у бэкендеров, существует несколько вариантов, как нашу API тестировать. Если frontend-приложение уже написано, то мы можем тестировать (проверять) API с помощью этого приложения. Изучать Network и смотреть, что же происходит с нашим “бэкендом”, как он нам отвечает. Этот вариант всего лишь имеет место быть. Но это не самый лучший подход.

// Второй подход - это когда мы писали какой-то одноразовый код, который API проверял и который по итогу мы можем выбросить. Такой подход также не самый хороший.

// Третий подход, который нам предлагает современный мир, это использовать Postman - программу, с помощью которой мы можем делать запросы на нашу API и, опять же, глазами проверять, что всё хорошо. При этом данная программа настолько мощная, что там можно проверять не только глазами, но и с помощью программного кода. Вообще, Postman позиционирует себя, как целая платформа. Некий тестовый инструмент. И многие автоматизаторы им пользуются.

// Но! Не пользуйтесь Postman, как будто его не существует вовсе.

// А как же нам тогда проверять, что наша API работает? С помощью тестов.

// В JavaScript это Jest. Мы с помощью кода описываем, какой мы хотим сделать запрос и что хотим получить. Запускаем тест, и он делает запрос к API и проверяет ответ. 

//Отпадает человеческий фактор: нам уже не нужно глазами внимательно всё изучать. В плане скорости такого варианта тестирования мы лишь на немного дольше делаем всё это, чем, например, тестировали бы в Postman. Но идея такая, что массовой культуры работы с Postman нет. Нам, как программистам, проще разговаривать на языке программного кода.

// Мы можем, с помощью программного кода, делать циклы, генерации данных, какие-то пограничные условия. Можем читать, вместо глаз, данные, которые нам вернулись. Мы можем делать различные комбинации и т.д.

// С помощью программного кода мы гораздо надёжнее и быстрее протестируем нашу API. При этом, как некий побочный продукт, у нас остаются тесты. И мы эти тесты, так как это программный код, который лежит в одной кодовой базе с нашим “бэкендом”, можем постоянно запускать и проверять, что наша кодовая база работает корректно.

// Мы пишем эти тесты, чтобы ускорить разработку и удостовериться, что тот код, который мы написали, работает.

// Тесты, которые мы сегодня будем писать - это E2E тесты. Мы отправляем системе запрос и получаем ответ. Наша система - это некий чёрный ящик. Мы понятия не имеем, что там происходит.

// E2E тесты очень быстрые с точки зрения написания, но самые непонятные с точки зрения “А почему оно не работает?”. Если эти тесты говорят, что что-то не работает, то искать концы нужно где-то во всей кодовой базе. Но так как наша задача в контексте данного урока - проверять, что наш backend работает, то такое тестирование является уместным.

// Для написания тестов нам понадобится определённый ряд инструментов: Jest, TypeScript, Supertest (утилита, которая позволяет запускать наше приложение и делать запросы).

// В терминале пишем: yarn add jest ts-jest @types/jest supertest @types/supertest
// ts-jest - это трансформатор, который позволяет Jest понимать TypeScript.
// @typescript/jest - работает в обратную сторону, чтобы TypeScript понимал Jest.

// Следующим шагом нужно создать jest.config.js - конфигурационный файл для Jest, чтобы настроить его работу. Способ его создания возьмём из туториала.  yarn ts-jest config:init