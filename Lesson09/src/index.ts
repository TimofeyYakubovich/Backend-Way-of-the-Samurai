
// используя Express вместе с TypeScript, будем строить REST API. Наше приложение будет уметь реагировать на приходящие request, считывать его метод (GET, POST, PUT, DELETE), считывать переданное в формате JSON body, query и URI-параметры, возвращать response различного типа, в том числе выставляя нужный “status code”, чтобы клиент мог его проанализировать и понять, что в принципе произошло.

// сейчас настраино TypeScript-окружение нашего приложения. У нас запущен процесс, который следит за “тайпскриптовыми” файлами, билдит их. И есть запущенный nodemon, который запускает “джаваскриптовый” файл в папке “dist” и слушает порт 3000. У нас создано Express-приложение, установлен 3000-й порт, и это приложение настроено с помощью метода “get” объекта “app”

// Запрос будем делать с помощью нативного метода fetch Консоль в Dev Tools нужно открыть, находясь по адресу запущенного приложения (http://localhost:3000)
// fetch('http://localhost:3000', {method: 'GET'})
//     .then(res => res.json())
//     .then(json => console.log(json))

// плучаем объект Object { message: "IT - INCUBATOR.RU" }

// методе “send”, который является чересчур “навороченно-универсальным”, и чересчур умным.

// Перейдём в Network, в консоли еще раз сделаем запрос. Увидим в Network этот запрос:
// Видим метод “GET”, статус 200. Если кликнуть по этому запросу, увидим, что в response вернулся Content-Type: application/json:
// Т.е. метод “send” объекта “res” увидел, что мы передали ему объект, и автоматически сказал: “Я возвращаю вам JSON”. Поэтому в ответ “улетел” JSON. 

// Если в ответ вернуть просто строку: res.send('IT - INCUBATOR.RU')
// Ошибка ввиду невозможности вывести в консоль не JSON (в ответ “улетает” просто строка). Но если мы пойдём в Network, то увидим, что в Response Headers Content Type у нас “text/html”:
// Можем в ответ вернуть тег “h1”: res.send('<h1>IT - INCUBATOR.RU</h1>')

// Мало того, что метод “send” умеет понимать, передаём мы в него строку или объект, он ещё может понимать, что мы передаём в него число. И число будет интерпретироваться как status code res.send(404)

// Упала ошибка “404 Not Found”. Два “then” не сработали, так как промис вернулся в состояние reject. В Network также увидим, что запрос “упал” с ошибкой и у нас 404-й статус

// Мы передали методу “send” 404. Он понимает, что речь идёт о status code, и автоматически воспринимает это число как код. Поэтому, если вдруг вы захотите передать число как ответ, то у вас ничего не получится. Если вы хотите вернуть 200-й ответ, но передать какое-то число

// В данном случае число 1000 он интерпретировал как status code, а такой статус не валидный. Поэтому “упала” серверная ошибка со статусом 500. Нужно перезапустить сервер

// Мы убедились, что метод “send” чересчур навороченный. Поэтому не рекомендуется его повсеместно использовать, кроме случаев, когда нам важно, чтобы этот метод автоматически подстраивал контент, который по каким-то причинам может быть динамическим. Если мы хотим сделать программу более предсказуемой и контролируемой, то лучше использовать методы, которые предназначены для конкретных действий.

// Например: если нужно отправить JSON файл: res.json({message: 'IT - INCUBATOR.RU'}) пришло Object { message: "IT - INCUBATOR.RU" }
// Если мы попытаемся вернуть строку res.json('IT - INCUBATOR.RU') пришло IT - INCUBATOR.RU
// Если захотим вернуть число res.json(1000) пришло 1000
// Если нужно, чтобы появилась ошибка 404, то res.sendStatus(404)

// Явный код всегда лучше, чем неявный код, т.к. код не нуждается в догадках и передаёт наши намерения программистам.

import express from "express" 
const app = express()
const port = 3000

const HTTP_STATUSES = {
    OK_200: 200,
    CREATED_201: 201,
    NO_CONTENT_204: 204,
    BAD_REQUEST_400: 400,
    NOT_FOUND_404: 404
}

const jsonBodyMiddleware = express.json() // Создадим этот промежуточный слой jsonBodyMiddleware путём вызова метода JSON у объекта Express
app.use(jsonBodyMiddleware) // скажем нашему приложению использовать его, прежде чем отправлять request в обработчики

const db = {
    courses: [
        {id: 1, title: 'front-end'},
        {id: 2, title: 'back-end'},
        {id: 3, title: 'automation qa'},
        {id: 4, title: 'devops'}
    ]
}

app.get('/', (req, res) => {  // колбек или хендлер обработчик запроса
    // res.send({message: 'IT - INCUBATOR.RU'}) // возвращаем в респонс с поммощью метода send объект 
    // res.send('IT - INCUBATOR.RU')
    // res.send('<h1>IT - INCUBATOR.RU</h1>')
    // res.send(404)
    // res.send(1000)
    // res.json({message: 'IT - INCUBATOR.RU'})
    // res.json('IT - INCUBATOR.RU')
    // res.json(1000)
    res.sendStatus(404)
})

app.get('/courses', (req, res) => {
    // res.json([
    //     {id: 1, title: 'front-end'},
    //     {id: 2, title: 'back-end'},
    //     {id: 3, title: 'automation qa'},
    //     {id: 4, title: 'devops'}
    // ])  

    let foundCourses = db.courses;

    if (req.query.title) {
        foundCourses = foundCourses.filter(c => c.title.indexOf(req.query.title as string) > -1)
    }

    // if (!foundCourses.length) {
    //     res.sendStatus(404);
    //     return;
    // }

    // const foundCourses = db.courses.filter(c => c.title.indexOf(req.query.title as string) > -1)

    // res.json(db.courses);
    res.json(foundCourses);
})

app.get('/courses/:id', (req, res) => { // Делаем конфигурацию для нашего приложения, дублируем настройку и добавляем параметр id
    // res.json([
    //     {id: 1, title: 'front-end'},
    //     {id: 2, title: 'back-end'},
    //     {id: 3, title: 'automation qa'},
    //     {id: 4, title: 'devops'}
    // ].find(c => c.id === +req.params.id))

    // const FoundCourse = [
    //     {id: 1, title: 'front-end'},
    //     {id: 2, title: 'back-end'},
    //     {id: 3, title: 'automation qa'},
    //     {id: 4, title: 'devops'}
    // ].find(c => c.id === +req.params.id) 

    const FoundCourse = db.courses.find(c => c.id === +req.params.id) 

    if (!FoundCourse) {  // Как правило, с массивами так не делается
        // res.sendStatus(404);
        res.sendStatus(HTTP_STATUSES.NOT_FOUND_404);
        return;
    }

    res.json(FoundCourse) 
})

app.post('/courses', (req, res) => {

    if (!req.body.title) {
        // res.sendStatus(400)
        res.sendStatus(HTTP_STATUSES.BAD_REQUEST_400)
        return;
    }

    const createdCourse = {
        id: +(new Date()),
        // title: 'unknown'
        title: req.body.title
    }

    db.courses.push(createdCourse)
    console.log(createdCourse)
    // res.status(201).json(createdCourse)
    res.status(HTTP_STATUSES.OK_200).json(createdCourse)
})

app.delete('/courses/:id', (req, res) => {

    db.courses = db.courses.filter(c => c.id !== +req.params.id) 

    // res.sendStatus(204) 
    res.sendStatus(HTTP_STATUSES.NO_CONTENT_204) 
})

app.put('/courses/:id', (req, res) => { 

    if (!req.body.title) {
        // res.sendStatus(400)
        res.sendStatus(HTTP_STATUSES.BAD_REQUEST_400)
        return;
    }

    const FoundCourse = db.courses.find(c => c.id === +req.params.id) 

    if (!FoundCourse) {
        // res.sendStatus(404);
        res.sendStatus(HTTP_STATUSES.NOT_FOUND_404);
        return;
    }

    FoundCourse.title = req.body.title;

    // res.sendStatus(204) 
    res.sendStatus(HTTP_STATUSES.NO_CONTENT_204) 
})

app.listen(port, () => {   // запускаем приложение через вызов метода listen передаем port и колбек
  console.log(`Example app listening on port ${port}`)
})

// Теперь попробуем построить пару GET endpoint’ов, которые будут работать с каким-то ресурсом. В качестве ресурса будет выступать “courses”:
// Нам нужно вернуть массив курсов. Мы создаём курсы внутри массива:
// Каждый курс является сущностью, у каждой сущности должен быть идентификатор, который эту сущность характеризует. Также у сущности есть своя характеристика (title)

// отправляем запрос fetch('http://localhost:3000/courses', {method: 'GET'}) получаем Array(4) [ {…}, {…}, {…}, {…} ]

// Теперь нужно сделать URL-запрос, который будет среди множества курсов искать конкретный курс с конкретным id, например 2:

// Делаем конфигурацию для нашего приложения, дублируем настройку и добавляем параметр id:
// Из этого массива нужно вернуть тот элемент. С помощью метода find находим в массиве элемент, id которого равна той id, которая прилетела нам в качестве URI-параметра (сидят в объекте “params” объекта “req”):  .find(c => c.id === req.params.id)

// c.id === req.params.id TypeScript ругается из-за того, что URI-параметра это строка, а именно часть строки. Поэтому мы должны привести ее к числу: .find(c => c.id === +req.params.id)

// отправляем запрос fetch('http://localhost:3000/courses/2' получаем Object { id: 2, title: "back-end" }

// Если будем запрашивать тот курс, которого нет, то прилетит ошибка:
// В response ничего не вернулось, потому что метод “find” не нашел такого курса и вернул нам undefined.
// Если того, что мы запрашиваем, нет, то должен вернуться 404 статус.

// Вынесем поиск элемента в отдельную переменную. Выделяем. Нажимаем Ctrl+Alt+V, что означает выделение и рефакторинг переменной const foundCourse
// Перед тем как его забрасывать в JSON, проверим на его наличие. if (!FoundCourse) Если курса нет, то отправим 404-й статус и оборвём callback-функцию:

// вынесим массив в отдельную переменную db 


// Следующим шагом доработаем эндпоинт, который возвращает нам массив курсов.

// Сделаем так, чтобы на стороне клиента у нас была возможность эти курсы фильтровать. Фильтры всегда гибкие. Поэтому фильтрацию мы должны делать с помощью query-параметров - то, что добавляется через вопросительный знак (“?”) и соединяется через “амперсанд” (“&”)

// fetch('http://localhost:3000/courses?title=end', {method: 'GET'})
//     .then(res => res.json())
//     .then(json => console.log(json)) 

// При этом в фильтрации мы будем учитывать “частичное вхождение”. Например, по слову “end”. Соответственно, сделав запрос, мы хотим получить курсы, в названии которых есть кусочек “end”.

// Соответственно, работать будем с “db.courses” и фильтровать оттуда ненужные данные.

// Для этого вынесем фильтрацию в отдельную переменную, где методом “filter” будем фильтровать курсы (будут возвращены только те, в названии которых есть то, что приходит в query-параметре “title”) и затем найденные курсы вернём в ответе:

// const foundCourses = db.courses.filter(c => c.title.indexOf(req.query.title as string) > -1)

// Переданные query-параметры мы достаём из объекта “req.query”. “as string” пишем, чтобы не ругался TypeScript.
// Выполним еще раз предыдущий запрос и увидим, что вернулось два курса

// Если передавать различные варианты query-параметра “title”, массив курсов будет фильтроваться. Но попробуем не передавать этот параметр
// Нам не вернулось ничего []. Хотя подразумевается, что если мы ничего не передаём, то нам должны вернуться все курс
// Если мы не передаём query-параметр “title”, то он у нас будет “undefined”. Соответственно, передавая “undefined” в “indexOf”, наша фильтрация сломается и нам никакие курсы не вернутся

// Поэтому, прежде чем сделать фильтрацию, можно сделать такой трюк
// if (req.query.title) {
//     foundCourses = foundCourses.filter(c => c.title.indexOf(req.query.title as string) > -1)
// }

// Сначала присваиваем переменной все курсы. Затем говорим: “Если в query-параметрах есть “title”, то переопредели переменную и дай ей новым значением отфильтрованные курсы
// делаем ещё раз запрос курсов и увидим, что вернулись все четыре курса

// Нужно ли возвращать ошибку 404, если у нас массив пустой?

// Как правило, с массивами так не делается. Если подразумевается, что мы запрашиваем массив ресурсов и есть какая-либо навороченная фильтрация, которая не возвращает ничего, то мы просто возвращаем пустой массив. Есть API, которые могут возвращать ошибку, но это не очень распространённая практика. Поэтому не нужно делать проверку на “пустоту” и возвращать 404-ю ошибку.


// Давайте научимся создавать курсы.

// Реализуем это, если на эндпоинт “/courses” прилетит post-запрос

// “id” никогда не прилетает с клиента. Генерация “id” это всегда ответственность “бэкенда”. Иногда это ответственность самого программного кода. Иногда это ответственность базы данных или внешней системы, которая может предоставить нам какой-либо идентификатор. В нашем случае ответственность за генерацию “id” несёт наш обработчик (генерация id путём приведения к числу созданной даты). Не используйте такой способ генерации в продакшене!

// Дальше добавляем “title”. Есть различные сценарии создания записи. Иногда есть сценарий, когда мы с клиента отправляем запрос и говорим “бэкенду” создать пустую заглушку, как в нашем случае.

// Что мы должны вернуть в качестве ответа? Иногда возвращается сущность, которая была создана, как в нашем случае.

// Отправим post-запрос и увидим, что курс создался

// fetch('http://localhost:3000/courses', {method: 'POST'})
//     .then(res => res.json())
//     .then(json => console.log(json)) 

// Свойств у создаваемого объекта может быть много. Иногда часть свойств и прочих характеристик устанавливается какой-то бизнес-логикой на “бэкенде” и “фронтенд” об этом не знает.

// Иногда какой-то набор данных мы хотим контролировать во время создания сущности. Например, создадим не просто какой-то “пустой” курс, а курс с каким-то конкретным названием, как чаще всего и делается. Мы должны как-то передать данные на наш “бэкенд”.

// Делается это с помощью “body” (“payload”, нагрузки). Для того, чтобы с помощью fetch отправить какие-то данные, мы должны отправить объект с данными в body запроса

// Body - это JSON, и мы отправим объект со свойством “title”. В качестве body мы можем положить файл, строку, число. Но, как правило, нужно упаковывать это в объект. И, вообще, желательно с “бэкенда” возвращать что-то, упакованное в объект- так же, как и с “фронта”, не слать какие-то примитивы, а всё-таки их упаковывать в какие-то объекты.

// Если отправим этот post-запрос, то нам по-прежнему вернётся тот же ответ

// fetch('http://localhost:3000/courses', {method: 'POST', body: {title: 'dba'}})
//     .then(res => res.json())
//     .then(json => console.log(json)) 

// Почему? Потому что мы никак не обрабатываем body. Он прилетает к нам в request, но мы никак не обрабатываем его. Исправим это title: req.body.title

// Сделаем запрос ещё раз. Видим, что упала ошибка. Проанализируем терминал и увидим там ошибку “Cannot read properties of undefined (reading ‘title’)”. То есть программа не может прочитать свойство “title” у undefined. Соответственно body у нас undefined. Почему так? Ведь мы же передаём body.

// Чтобы иметь доступ к body в обработчике нашего запроса, нужно чтобы express предварительно “распарсил” его. 

// Для этого мы подключим middleware - это функция-handler, которая вызовется перед нашим обработчиком и что-то там подготовит. В нашем случае этот промежуточный слой прочитает body и сделает его заполненным объектом.

// Настроить промежуточный слой нужно вверху, перед настройкой всех маршрутов, чтобы он самым первым отреагировал на входящий запрос

// const jsonBodyMiddleware = express.json() // Создадим этот промежуточный слой путём вызова метода JSON у объекта Express
// app.use(jsonBodyMiddleware)  // скажем нашему приложению использовать его, прежде чем отправлять request в обработчики

// Проверим, всё ли хорошо. Сделаем ещё раз запрос: Object { id: 1677674694993 }
// Видим, что ошибка не упала, но в ответе вернулся только “id”. Body теперь не undefined, но undefined почему-то “title”. Если у нас какое-то свойство равно undefined, то, когда мы его закидываем в JSON, чтобы вернуть на “клиент”, оно у нас просто не возвращается. По этой причине у нас “title” и не возвращается.

// Выведем в консоль созданный курс Отправим ещё раз запрос и в консоли увидим, что свойство “title” объекта равно undefined
// { id: 1677674867293, title: undefined }

// Так происходит по той причине, что, когда мы отправляем post-запрос, важно в каком формате мы отправляем данные на “бэкенд”.
// Если в Network открыть информацию о нашем запросе, то мы увидим, что мы отправляем данные в формате Content-Type text/plain;
// А мы подключили промежуточный слой, который является JSON’овским и он ожидает, что к нам прилетит объект JSON. Но так как там не JSON, то у нас всё плохо.
// Поэтому, когда мы делаем отправку данных, в заголовках мы должны установить “content-type”: “application/json” (названия заголовков не чувствительны к регистру):

// Сделаем запрос:
// fetch('http://localhost:3000/courses', {method: 'POST', body: {title: 'dba'},
// headers: {
//     'content-type': 'application/json'
// }})
//     .then(res => res.json())
//     .then(json => console.log(json)) 

// Упала 400-я ошибка. Каким-то образом кто-то отправил 400-й код нашему клиенту. Сделал это скорее всего middleware, который понял, что нам прислали вроде бы и JSON, но “плохой” JSON. Он не смог его “распарсить”, не пустил код выполняться дальше и вернул 400-й ответ. При этом приложение наше продолжает работать и ошибку можно увидеть в терминале IDE.

// Причина в том, что в fetch, который мы используем, body нужно передавать не просто в виде объекта, а в виде объекта, превращённого в строку. Когда мы превращаем объект в строку либо, например, в массив битов, это называется сериализация (бинарная, строковая). В JavaScript строковая сериализация делается с помощью JSON.stringify. 

// Выполним это для объекта, передаваемого в body и сделаем запрос:
// fetch('http://localhost:3000/courses', {method: 'POST', body: JSON.stringify({title: 'dba'}),
// headers: {
//     'content-type': 'application/json'
// }})
//     .then(res => res.json())
//     .then(json => console.log(json)) 

// Теперь никаких ошибок не упало и в ответе нам вернулся объект, где есть свойство “title”.

// Добавим небольшую валидацию “title”. Проверим, что если вдруг “title” нам не передали, прервём функцию-обработчик и, предварительно, вернём 400-й статус:
// Выполним запрос, передав в качестве “title” пустую строку, и увидим ошибку с 400-м статусом (говорит нам о том, что клиент отправил что-то не то)

// Добавим ещё одно небольшое улучшение. Сделаем так, чтобы при успешном запросе нам возвращался ответ с 201-м кодом. Но мы можем отправить в качестве ответа статус (“res.sendStatus”), а можем отправить JSON (“res.json”). Как нам отправить и то, и другое?

// Для этого в response перед отправкой JSON устанавливаем статус res.status(201).json(createdCourse)
// Теперь, если сделаем запрос на создание, то в Netwok сможем увидеть, что ответ вернулся с 201-м статусом




// Теперь нужно научиться что-то удалять и что-то редактировать.

// Начнём с удаления, так как удаление очень похоже на логику GET-запроса. Копируем логику GET-запроса “/courses/:id”. Сразу же меняем “get” на “delete”.

// Delete-запрос прилетает с клиента, чтобы удалить какую-то сущность, “id” которой передаётся как URI-параметр. Каким-то образом из базы данных мы должны удалить этот курс. Реализуем это самым простым способом: напрямую возьмём курсы из нашей вымышленной базы данных и отфильтруем их по “id”.

// Если вдруг курс не удалился ввиду того, что его не существует? Можем сказать, что удалено, хотя по факту ничего не удалялось. Можем вернуть статус 404. И этот вариант будет лучше.

// При успешном удалении варианты ответа тоже могут быть разными. Можно вернуть клиенту удалённую сущность: “Клиент, попользуйся ей в последний раз”. Но чаще всего она не возвращается, и мы возвращаем статус 204 - “No Content”.

// Выполним delete-запрос
// fetch('http://localhost:3000/courses/1', {method: 'DELETE',})
//     .then(res => res.json())
//     .then(json => console.log(json)) 

// Несмотря на то, что в консоли упала ошибка, ввиду того что мы пытаемся в “then” обработать json, а он нам не возвращается в ответе, анализируя Network, мы можем увидеть, что наш запрос успешно выполнен с 204-м кодом

// Проверим, что наш объект удалился. Для этого сделаем get-запрос за всеми курсами баз фильтраци



// И последняя операция, которую нам осталось сделать, это PUT- обновление. Обновление будет похоже на DELETE и на POST. Копируем GET-запрос, где мы искали курс по “id”. Вместо “get” напишем “put”. Находим по “id” курс, который хотим обновить, и если курс не найден, возвращаем ошибку 404

// Но если курс нашёлся, мы его обновляем. Скажем: “Возьми у курса “title” и присвой ему значение, которое пришло в body”:
// При этом, как и с созданием, мы можем сделать небольшую валидацию: если “title” не придёт, то вернём 404-ю ошибку:
// Вернуть мы можем как и отредактированный объект, так и просто статус, например 204-й - res.sendStatus(204), как было в случае с DELETE.

// Попробуем отправить put-запрос. Важный момент. В URI-параметрах у нас должна быть отправлена “id”, а в body мы отправляем “title”:
// fetch('http://localhost:3000/courses/1', {method: 'PUT', body: JSON.stringify({title: 'dba'}),
// headers: {
//     'content-type': 'application/json'
// }})
//     .then(res => res.json())
//     .then(json => console.log(json))

// Ошибка в консоли может возникнуть, если вы решили вернуть статус вместо отредактированного объекта. Но если мы перезапросим (get) наши объекты, то увидим изменённое свойство “title” у первого:

// Вишенка на тортике касаемо статус кодов, которые возвращаем. Давайте создадим константу, внутри которой будут статусы:
