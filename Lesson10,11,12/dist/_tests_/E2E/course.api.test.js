"use strict";
// Мы должны делать проверку того, что наше приложение, наш бэкенд, работает. Проверка равно тестирование. По своей сути тестирование представляет собой определённые концепции, связанные с написанием тестов, пирамиду тестирования: интеграционные тесты, E2E тестирование, unit-тесты и т.д. 
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Есть определённые правила и принципы, по которым строятся тесты. В данном уроке мы всё это отбросим. И, хоть мы будем писать тесты, мы это не будем называть тестированием. А будем называть это проверкой.
// Мы проверяем, что наш API работает. А уже как какой-то побочный эффект у нас остаются тесты. В какой-то степени не совсем идеальные тесты. Но, тем не менее, сложно поспорить с тем, что наличие этих тестов очень полезно
// Когда “фронтендер” пишет своё приложение, он обязательно запускает его и у него обязательно есть user interface, который он непосредственно видит глазами. Он смотрит на этот интерфейс. Руками он с ним взаимодействует и проверяет, что приложение работает предсказуемо, ожидаемо - так, как он его запрограммировал. За счёт чего это происходит? За счёт того, что у нас есть user interface (UI), который подразумевает наличие пользователя. 
// Мы, как backend-разработчики, сидим «в подвале» и пишем скучную API. Интерфейс вроде есть и там, и там. Но это программный интерфейс, с которым взаимодействует другая программа: frontend-приложение. И нам тестировать нашу API уже не так уж интересно.
// В какой-то степени frontend тестирует API - он с ним взаимодействует и егопроверяет. Нечто подобное мы делали, когда писали код, который делает запросы к нашей API. Мы проверяли, что наша API работает. Именно проверяли. Не тестировали.
// У нас, как у бэкендеров, существует несколько вариантов, как нашу API тестировать. Если frontend-приложение уже написано, то мы можем тестировать (проверять) API с помощью этого приложения. Изучать Network и смотреть, что же происходит с нашим “бэкендом”, как он нам отвечает. Этот вариант всего лишь имеет место быть. Но это не самый лучший подход.
// Второй подход - это когда мы писали какой-то одноразовый код, который API проверял и который по итогу мы можем выбросить. Такой подход также не самый хороший.
// Третий подход, который нам предлагает современный мир, это использовать Postman - программу, с помощью которой мы можем делать запросы на нашу API и, опять же, глазами проверять, что всё хорошо. При этом данная программа настолько мощная, что там можно проверять не только глазами, но и с помощью программного кода. Вообще, Postman позиционирует себя, как целая платформа. Некий тестовый инструмент. И многие автоматизаторы им пользуются.
// Но! Не пользуйтесь Postman, как будто его не существует вовсе.
// А как же нам тогда проверять, что наша API работает? С помощью тестов.
// В JavaScript это Jest. Мы с помощью кода описываем, какой мы хотим сделать запрос и что хотим получить. Запускаем тест, и он делает запрос к API и проверяет ответ. 
//Отпадает человеческий фактор: нам уже не нужно глазами внимательно всё изучать. В плане скорости такого варианта тестирования мы лишь на немного дольше делаем всё это, чем, например, тестировали бы в Postman. Но идея такая, что массовой культуры работы с Postman нет. Нам, как программистам, проще разговаривать на языке программного кода.
// Мы можем, с помощью программного кода, делать циклы, генерации данных, какие-то пограничные условия. Можем читать, вместо глаз, данные, которые нам вернулись. Мы можем делать различные комбинации и т.д.
// С помощью программного кода мы гораздо надёжнее и быстрее протестируем нашу API. При этом, как некий побочный продукт, у нас остаются тесты. И мы эти тесты, так как это программный код, который лежит в одной кодовой базе с нашим “бэкендом”, можем постоянно запускать и проверять, что наша кодовая база работает корректно.
// Мы пишем эти тесты, чтобы ускорить разработку и удостовериться, что тот код, который мы написали, работает.
// Тесты, которые мы сегодня будем писать - это E2E тесты. Мы отправляем системе запрос и получаем ответ. Наша система - это некий чёрный ящик. Мы понятия не имеем, что там происходит.
// E2E тесты очень быстрые с точки зрения написания, но самые непонятные с точки зрения “А почему оно не работает?”. Если эти тесты говорят, что что-то не работает, то искать концы нужно где-то во всей кодовой базе. Но так как наша задача в контексте данного урока - проверять, что наш backend работает, то такое тестирование является уместным.
// Для написания тестов нам понадобится определённый ряд инструментов: Jest, TypeScript, Supertest (утилита, которая позволяет запускать наше приложение и делать запросы).
// В терминале пишем: yarn add jest ts-jest @types/jest supertest @types/supertest
// ts-jest - это трансформатор, который позволяет Jest понимать TypeScript.
// @typescript/jest - работает в обратную сторону, чтобы TypeScript понимал Jest.
// Следующим шагом нужно создать jest.config.js - конфигурационный файл для Jest, чтобы настроить его работу. Способ его создания возьмём из туториала.  yarn ts-jest config:init
// Теперь в package.json создадим скрипт под названием “test”, который будет запускать команду “jest”: На данном этапе Jest скажет нам, что у нас ещё нет тестов и ещё нечего запускать
// Создадим первый тест. Для этого создаём новые папки и файл в корне проекта: папку _tests_, в которой будет папка E2E, и уже в ней файл course.api.test.ts.
// Теперь пробуем написать тест. Все тесты должны объединяться в какие-то группы. Используем функцию describe. Ей говорим, что мы будем тестировать, и передаём callback-функцию
const supertest_1 = __importDefault(require("supertest"));
// import { app } from "../../src/app"
// import { HTTP_STATUSES } from "../../src/app"
const app_1 = require("../../src/app");
const utils_1 = require("../../src/utils");
const getRequest = () => {
    return (0, supertest_1.default)(app_1.app);
};
describe('/courses', () => {
    beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
        // await request(app).delete('/__test__/data')
        yield getRequest().delete('/__test__/data');
    }));
    it('should return 200 and empty array', () => __awaiter(void 0, void 0, void 0, function* () {
        // expect(1).toBe(1)
        // await request(app)
        yield getRequest()
            .get('/courses')
            .expect(utils_1.HTTP_STATUSES.OK_200, []);
        // .expect(200, [
        //     {id: 1, title: 'front-end'},
        //     {id: 2, title: 'back-end'},
        //     {id: 3, title: 'automation qa'},
        //     {id: 4, title: 'devops'}
        // ])
    }));
    it('should return 404 for not existing course', () => __awaiter(void 0, void 0, void 0, function* () {
        // await request(app)
        yield getRequest()
            .get('/courses/1')
            .expect(utils_1.HTTP_STATUSES.NOT_FOUND_404);
    }));
    it(`should'nt create course with correct input data`, () => __awaiter(void 0, void 0, void 0, function* () {
        const data = { title: '' }; // типизируем то что оправляем бекенду
        // await request(app)
        yield getRequest()
            .post('/courses')
            // .send({title: ''})
            .send(data)
            .expect(utils_1.HTTP_STATUSES.BAD_REQUEST_400);
        // await request(app)
        yield getRequest()
            .get('/courses')
            .expect(utils_1.HTTP_STATUSES.OK_200, []);
    }));
    let createCourse1 = null;
    it(`should create course with correct input data`, () => __awaiter(void 0, void 0, void 0, function* () {
        const data = { title: 'it-incubator course' }; // типизируем то что оправляем бекенду
        // const createResponse = await request(app) // response Запишем его в переменную createResponse
        const createResponse = yield getRequest()
            .post('/courses')
            // .send({title: 'it-incubator course'})
            .send(data)
            .expect(utils_1.HTTP_STATUSES.CREATED_201);
        createCourse1 = createResponse.body; // У createResponse есть body - это то, что возвращается с response назад. Положим это в переменную createdCourse:
        expect(createCourse1).toEqual({
            id: expect.any(Number),
            title: 'it-incubator course' // у которого есть title с определённым названием
        });
        // await request(app)
        yield getRequest()
            .get('/courses')
            .expect(utils_1.HTTP_STATUSES.OK_200, [createCourse1]);
    }));
    let createCourse2 = null;
    it(`create one more course`, () => __awaiter(void 0, void 0, void 0, function* () {
        const data = { title: 'it-incubator course 2' }; // типизируем то что оправляем бекенду
        // const createResponse = await request(app) // response Запишем его в переменную createResponse
        const createResponse = yield getRequest() // response Запишем его в переменную createResponse
            .post('/courses')
            // .send({title: 'it-incubator course 2'})
            .send(data)
            .expect(utils_1.HTTP_STATUSES.CREATED_201);
        createCourse2 = createResponse.body; // У createResponse есть body - это то, что возвращается с response назад. Положим это в переменную createdCourse:
        expect(createCourse2).toEqual({
            id: expect.any(Number),
            // title: 'it-incubator course 2' // у которого есть title с определённым названием
            title: data.title // у которого есть title с определённым названием
        });
        // await request(app)
        yield getRequest()
            .get('/courses')
            .expect(utils_1.HTTP_STATUSES.OK_200, [createCourse1, createCourse2]);
    }));
    it(`should'nt updata course with in correct input data`, () => __awaiter(void 0, void 0, void 0, function* () {
        const data = { title: '' }; // типизируем то что оправляем бекенду
        // await request(app) // response Запишем его в переменную createResponse
        yield getRequest()
            .put('/courses/' + createCourse1.id)
            // .send({title: ''})
            .send(data)
            .expect(utils_1.HTTP_STATUSES.BAD_REQUEST_400);
        // await request(app)
        yield getRequest()
            .get('/courses/' + createCourse1.id)
            .expect(utils_1.HTTP_STATUSES.OK_200, createCourse1);
    }));
    it(`should'nt updata course that not exist`, () => __awaiter(void 0, void 0, void 0, function* () {
        // await request(app) // response Запишем его в переменную createResponse
        yield getRequest()
            .put('/courses/' + -100)
            .send({ title: 'good title' })
            .expect(utils_1.HTTP_STATUSES.NOT_FOUND_404);
    }));
    it(`should updata course with correct input data`, () => __awaiter(void 0, void 0, void 0, function* () {
        const data = { title: 'good new title' }; // типизируем то что оправляем бекенду
        // await request(app) // response Запишем его в переменную createResponse
        yield getRequest()
            .put('/courses/' + createCourse1.id)
            // .send({title: 'good new title'})
            .send(data)
            .expect(utils_1.HTTP_STATUSES.NO_CONTENT_204);
        // await request(app)
        yield getRequest()
            .get('/courses/' + createCourse1.id)
            .expect(utils_1.HTTP_STATUSES.OK_200, Object.assign(Object.assign({}, createCourse1), { 
            // title: 'good new title'
            title: data.title }));
        // await request(app)
        yield getRequest()
            .get('/courses/' + createCourse2.id)
            .expect(utils_1.HTTP_STATUSES.OK_200, createCourse2);
    }));
    it(`should delete both courses`, () => __awaiter(void 0, void 0, void 0, function* () {
        // await request(app) // response Запишем его в переменную createResponse
        yield getRequest()
            .delete('/courses/' + createCourse1.id)
            .expect(utils_1.HTTP_STATUSES.NO_CONTENT_204);
        // await request(app)
        yield getRequest()
            .get('/courses/' + createCourse1.id)
            .expect(utils_1.HTTP_STATUSES.NOT_FOUND_404);
        // await request(app) // response Запишем его в переменную createResponse
        yield getRequest()
            .delete('/courses/' + createCourse2.id)
            .expect(utils_1.HTTP_STATUSES.NO_CONTENT_204);
        // await request(app)
        yield getRequest()
            .get('/courses/' + createCourse2.id)
            .expect(utils_1.HTTP_STATUSES.NOT_FOUND_404);
        // await request(app)
        yield getRequest()
            .get('/courses')
            .expect(utils_1.HTTP_STATUSES.OK_200, []);
    }));
    it(' interesting should return 200 and empty array', () => __awaiter(void 0, void 0, void 0, function* () {
        yield getRequest()
            .get('/interesting')
            .expect(utils_1.HTTP_STATUSES.OK_200, []);
        // .expect(200, [
        //     {id: 1, title: 'front-end'},
        //     {id: 2, title: 'back-end'},
        //     {id: 3, title: 'automation qa'},
        //     {id: 4, title: 'devops'}
        // ])
    }));
    it(' interesting ID should return 200 and empty array', () => __awaiter(void 0, void 0, void 0, function* () {
        yield getRequest()
            .get('/interesting/4')
            .expect(utils_1.HTTP_STATUSES.OK_200, { title: 'data by id:' });
    }));
    it(' interesting books should return 200 and empty array', () => __awaiter(void 0, void 0, void 0, function* () {
        yield getRequest()
            .get('/interesting/books')
            .expect(utils_1.HTTP_STATUSES.OK_200, { title: 'it\'s books handler' });
        // .expect(HTTP_STATUSES.OK_200, [])
        // .expect(200, [
        //     {id: 1, title: 'front-end'},
        //     {id: 2, title: 'back-end'},
        //     {id: 3, title: 'automation qa'},
        //     {id: 4, title: 'devops'}
        // ])
    }));
});
// Внутри describe описываем тесты. Название теста должно быть уникальное. Внутри callback-функции описываем сам тест  
// В терминале пишем “yarn test” и компилируем Видим, что тест прошёл PASS 
// Теперь напишем более сложные тесты, с использованием библиотеки Supertest, в которых будем делать запросы к API. Данная библиотека позволяет импортировать объект request, с помощью которого мы можем делать запросы к backend’у. import  request  from "supertest"
// Но куда делать запросы? Библиотека Supertest запустит наше приложение. Но это приложение мы должны ей указать. Поэтому экспортируем приложение:  import { app } from "../../src"
// И импортируем его в наши тесты. И когда мы обращаемся к объекту request, мы “скармливаем” ему наше приложение: request(app)
// Далее нужно указать, какой запрос мы хотим сделать и на какой url: .get('/courses')
// Далее указываем, что мы ожидаем получить (200-й ответ, пустой массив): .expect(200, [])
// Запускаем: Видим, что упала ошибка, так как функция должна быть асинхронной: Поэтому в коде дописываем “async” и “await”: Перезапускаем тест: 
// И видим, что наш тест не прошёл, так как тест ожидает получить пустой массив, а получил массив объектов. Когда мы делаем get-запрос на наше приложение, нам возвращается, в нашем случае, захаркоженный массив объектов:
// Перезапускаем тест на текущей вкладке: И видим, что тест прошёл:
// Но такой тест не является гибким, т.к. мы зависим от захардкоженных данных. Поэтому нужно создать какой-то endpoint, который будет сбрасывать состояние БД (такое нельзя делать в production). app.delete('__test__/data', (req, res) => {
// Напишем два теста. Первый будет запрашивать курсы и должен будет получить пустой массив. Второй - запросит несуществующий курс и должен будет получить ошибку 404: 
// Теперь, перед запуском наших всех тестов, один раз выполним асинхронную функцию, в которой мы будем обращаться к нашему приложению и делать delete-запрос на адрес, который мы в приложении обозначили для зачистки массива курсов: beforeAll(async () => {
// Снова запускаем тесты:​ И видим, что тесты прошли.
// Зачистив БД и точно зная, что ничего нет, можем начать создавать данные. Напишем тест, который проверит, что курс не должен быть создан, если передаем невалидное название. По той же схеме, как и с предыдущими тестами: будем обращаться к нашему приложению, делать post-запрос на адрес “/courses” и отправим данные, где будет пустой title. И будем ожидать 401-й статус: it(`should'nt create course with correct input data`, async () => {
// Запускаем тест и видим, что всё хорошо:
// Теперь, если вдруг в запросе на создание курса мы допустили ошибку и забыли в условии указать “!”:
// То запустив ещё раз тест, мы увидим, что он упадёт с ошибкой:
// А если в логике приложения была допущена ошибка и сразу был создан курс, а потом выполнена проверка? Наш тест всё равно пройдёт в таком случае.
// И как бы мы это делали в Postman? Сделали бы запрос на создание. Увидели бы, что запрос прошёл. Затем запросили бы все курсы и убедились, что курс добавился. Обыграем этот момент и в наших тестах, сделав комбинацию запросов.
// В тесте на создание курса сделаем сразу после запроса на создание запрос за всеми курсами и проверим, что наш пустой массив остался пустым массивом. Так как мы при создании отправили невалидный title, по идее курс не должен быть создан:
// Запускаем тест и видим ошибку, которую специально допустили на бэкенде, перенеся проверку вниз:
// Откатываем назад изменения в приложении, которые мы специально сделали. Перезапускаем тесты и видим, что всё хорошо и тесты эти прошли.
// Теперь напишем тест, который должен создать курс. При этом, курс должен вернуться назад: 
// Jest, когда делает какой-либо запрос, возвращает response. Запишем его в переменную createResponse:
// У createResponse есть body - это то, что возвращается с response назад. Положим это в переменную createdCourse:
// И выполним проверку. Скажем, что созданный курс должен быть объектом, у которого есть title с определённым названием, и id, которая является каким угодно числом
// Но! Создался ли курс по-настоящему? Или в базу данных забыли положить? Т.е. push не произошёл. Валидацию сделали, сформировали объект и вернули его, а вот в базу данных объект положить забыли:
// Поэтому в тесте скажем: “Если объект создался, то мы потом, если сделаем get-запрос за всеми объектами, должны получить не пустой массив, а массив, в котором сидит “createdCourse””:
// Действительно, backend зафиксировал этот курс и нам вернул его при запросе всех курсов. Тестируем нашу систему дальше. Создание мы проверили. Теперь проверим update курса. Какого курса?
// По-хорошему, в теории тестирования, нам нужно стремиться к тому, чтобы каждый наш тест был независимым от предыдущих тестов. Мы должны эти тесты запускать параллельно, либо в любой последовательности, и должно всё работать. Наши тесты зависеть друг от друга будут. Поэтому мы не должны запускать их по одиночке, а запускать все сразу.
// Представьте, как бы мы тестировали через Postman. Наш нужно выполнить определённую последовательность запросов, чтобы проверить как всё работает: создать курс - запросить все курсы, чтобы проверить, что курс создался - обновить конкретный курс - снова запросить все курсы, чтобы проверить, что курс обновился. И если бы мы курс не создали, то как бы мы могли его обновить, если база данных пустая и там нет никаких данных.
// Соответственно, мы полагаемся на тест создания курса, что он будет запущен перед тестом на update курса:
// Делать будем put-запрос и отправляем id курса, который мы создали на этапе ранее. А как нам к нему достучаться? И проблема тут в том, что у нас замыкание и переменная createdCourse сидит внутри предыдущего теста и недоступна извне. Поэтому мы должны её выкинуть наружу, прямо за тест:
// Следующая функция, когда будет запускаться следующий тест, к этой переменной сможет достучаться. Но если тест на изменения курса будет запущен раньше, он не сработает, потому что createdCourse еще не будет сидеть в переменной:
// Отправим пустой title и скажем, что нам должен прийти “BAD_REQUEST_400”
// И для проверки мы сделаем запрос за конкретным, этим же курсом (протестируем одновременно получение данных по id), и должны получить createdCourse без изменений:
// Пишем следующий тест, в котором проверим, что курс не найден. Передадим на сервер id несуществующего курса и будем ожидать “NOT_FOUND_404”. При этом напишем в качестве id число, которое гарантировано не будет создано как id курса, чтобы случайно не совпала id и наш тест не упал
// Следующий тест - курс должен обновиться. Отправим id созданного курса. В качестве title - валидное значение. В ответе ожидаем получить “NO_CONTENT_204”, и перепроверим, что title курса изменился, сделав запрос за этим курсом, где мы скажем что должен прийти объект, копия объекта createdCourse, но с изменённым title
// Для теста на удаление курса напишем ещё один тест на создание курса, определив перед этим новую переменную createdCourse2 для нового курса. Для подобия переименуем предыдущую переменную в createdCourse1. И тест на создание второго курса положим рядом с тестом на создание первого. Скопируем логику теста на создание. Дадим второму курсу другой title
// Ответ присвоим переменной createdCourse2. Проверим, что он создался с нужным title и при запросе всех курсов вернется массив с двумя курсами
// Таким образом, в тесте на обновление мы сможем проверить, что обновился один курс, но не обновился второй. В тесте на проверку изменения первого курса сделаем проверку, что, если запросим второй курс, он должен быть без изменений
// Последний тест, который остался - проверить, что курс удаляется. Будем удалять оба курса. Делаем delete-запрос. Указываем id курса. Ожидаем, что вернётся “NO_CONTENT_204
// Затем сделаем запрос за этим курсом. Ожидаем, что придёт “NOT_FOUND_404”, потому что мы его удалили на шаг выше
// Удалим второй курс: скопируем предыдущие два запроса, достав id для запросов из второго курс
// И в конце сделаем запрос за всеми курсами и проверим, что массив остался пустым
// Перезапускаем наши тесты: Видим, что все тесты прошли:
// Мы проверили, что наша API работает. Не используя ни Postman, ни браузер. В скором времени мы сделаем рефакторинг кода. Запустим эти тесты и удивимся, что будет всё хорошо. Либо, если будет какая-то ошибка, мы увидим, что она случилась и у нас что-то не так.
// Рефакторинг, который мы будем делать, очень большой и фундаментальный. И, если бы не эти тесты, нам бы пришлось повторно вручную заново тестировать API.
